diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..02f1769
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,2 @@
+result
+.vscode
diff --git a/default.nix b/default.nix
new file mode 100644
index 0000000..e90c5c3
--- /dev/null
+++ b/default.nix
@@ -0,0 +1,41 @@
+{ pkgs, lib }:
+pkgs.stdenv.mkDerivation (finalAttrs: {
+    pname = "labwc";
+    version = "0.7";
+
+    src = ./.;
+
+    nativeBuildInputs = with pkgs; [
+      gettext
+      meson
+      ninja
+      pkg-config
+      scdoc
+      wayland-scanner
+    ];
+
+    buildInputs = with pkgs; [
+      cairo
+      glib
+      libdrm
+      libinput
+      libxkbcommon
+      libxml2
+      pango
+      wayland
+      wayland-protocols
+      wlroots_0_16
+      xwayland
+    ];
+
+    mesonFlags = [
+      (lib.mesonEnable "xwayland" false)
+    ];
+
+    meta = with lib; {
+      homepage = "https://github.com/dmitry-erin/labwc";
+      description = "A Wayland stacking compositor, similar to Openbox";
+      license = licenses.gpl2Plus;
+      inherit (pkgs.wayland.meta) platforms;
+    };
+  })
diff --git a/flake.lock b/flake.lock
new file mode 100644
index 0000000..2f28c10
--- /dev/null
+++ b/flake.lock
@@ -0,0 +1,61 @@
+{
+  "nodes": {
+    "flake-utils": {
+      "inputs": {
+        "systems": "systems"
+      },
+      "locked": {
+        "lastModified": 1694529238,
+        "narHash": "sha256-zsNZZGTGnMOf9YpHKJqMSsa0dXbfmxeoJ7xHlrt+xmY=",
+        "owner": "numtide",
+        "repo": "flake-utils",
+        "rev": "ff7b65b44d01cf9ba6a71320833626af21126384",
+        "type": "github"
+      },
+      "original": {
+        "owner": "numtide",
+        "repo": "flake-utils",
+        "type": "github"
+      }
+    },
+    "nixpkgs": {
+      "locked": {
+        "lastModified": 1700989516,
+        "narHash": "sha256-oKbmPa2wpTHh9XB3+zIx97uMZGNnp97GPliKKG2/plo=",
+        "owner": "NixOS",
+        "repo": "nixpkgs",
+        "rev": "d2e4de209881b38392933fabf303cde3454b0b4c",
+        "type": "github"
+      },
+      "original": {
+        "owner": "NixOS",
+        "ref": "nixos-23.05",
+        "repo": "nixpkgs",
+        "type": "github"
+      }
+    },
+    "root": {
+      "inputs": {
+        "flake-utils": "flake-utils",
+        "nixpkgs": "nixpkgs"
+      }
+    },
+    "systems": {
+      "locked": {
+        "lastModified": 1681028828,
+        "narHash": "sha256-Vy1rq5AaRuLzOxct8nz4T6wlgyUR7zLU309k9mBC768=",
+        "owner": "nix-systems",
+        "repo": "default",
+        "rev": "da67096a3b9bf56a91d16901293e51ba5b49a27e",
+        "type": "github"
+      },
+      "original": {
+        "owner": "nix-systems",
+        "repo": "default",
+        "type": "github"
+      }
+    }
+  },
+  "root": "root",
+  "version": 7
+}
diff --git a/flake.nix b/flake.nix
new file mode 100755
index 0000000..7b29812
--- /dev/null
+++ b/flake.nix
@@ -0,0 +1,28 @@
+{
+  description = "Labwc";
+
+  inputs = {
+    nixpkgs.url = "github:NixOS/nixpkgs/nixos-23.05";
+    flake-utils.url = "github:numtide/flake-utils";
+  };
+
+  outputs = inputs:
+    with inputs;
+      flake-utils.lib.eachDefaultSystem (
+        system: let
+          pkgs = import nixpkgs {
+            inherit system;
+          };
+        in rec {
+          packages = {
+            labwc = nixpkgs.legacyPackages.${system}.callPackage ./default.nix {
+              inherit pkgs;
+            };
+            default = packages.labwc;
+          };
+
+          formatter = nixpkgs.legacyPackages.${system}.alejandra;
+          devShells.default = pkgs.mkShell {};
+        }
+      );
+}
diff --git a/include/ssd-internal.h b/include/ssd-internal.h
index 9fe0ebf..6dfc2d4 100644
--- a/include/ssd-internal.h
+++ b/include/ssd-internal.h
@@ -118,8 +118,8 @@ struct ssd_part *add_scene_button(
 	struct wlr_buffer *icon_buffer, int x, struct view *view);
 struct ssd_part *add_scene_button_corner(
 	struct wl_list *part_list, enum ssd_part_type type,
-	enum ssd_part_type corner_type, struct wlr_scene_tree *parent,
-	struct wlr_buffer *corner_buffer, struct wlr_buffer *icon_buffer,
+	enum ssd_part_type corner_type, struct wlr_scene_tree *parent, 
+	float *bg_color, struct wlr_buffer *corner_buffer, struct wlr_buffer *icon_buffer,
 	int x, struct view *view);
 
 /* SSD internal helpers */
diff --git a/include/theme.h b/include/theme.h
index 47ef3b9..8ef632a 100644
--- a/include/theme.h
+++ b/include/theme.h
@@ -17,6 +17,12 @@ enum lab_justification {
 	LAB_JUSTIFY_RIGHT,
 };
 
+enum lab_corner {
+	LAB_CORNER_UNKNOWN = 0,
+	LAB_CORNER_TOP_LEFT,
+	LAB_CORNER_TOP_RIGHT,
+};
+
 struct theme {
 	int border_width;
 	int padding_height;
@@ -110,4 +116,55 @@ void theme_init(struct theme *theme, const char *theme_name);
  */
 void theme_finish(struct theme *theme);
 
+/**
+ * theme_create_custom_corner - create corners - rounded or not - using custom color
+ * @theme: theme data
+ * @lab_corner: corner enum value, top left or top right
+ * @bg_color: pointer to color array
+ */
+struct lab_data_buffer * theme_create_custom_corner(struct theme *theme, enum lab_corner corner, float *bg_color);
+
+/**
+ * theme_customize_with_border_color - fill in the given theme color fields by custom color
+ * @theme: theme data
+ * @color: pointer to color array
+ */
+void theme_customize_with_border_color(struct theme *theme, float *color);
+
+static int
+hex_to_dec(char c)
+{
+	if (c >= '0' && c <= '9') {
+		return c - '0';
+	}
+	if (c >= 'a' && c <= 'f') {
+		return c - 'a' + 10;
+	}
+	if (c >= 'A' && c <= 'F') {
+		return c - 'A' + 10;
+	}
+	return 0;
+}
+
+/**
+ * parse_hexstr - parse #rrggbb
+ * @hex: hex string to be parsed
+ * @rgba: pointer to float[4] for return value
+ */
+static void
+parse_hexstr(const char *hex, float *rgba)
+{
+	if (!hex || hex[0] != '#' || strlen(hex) < 7) {
+		return;
+	}
+	rgba[0] = (hex_to_dec(hex[1]) * 16 + hex_to_dec(hex[2])) / 255.0;
+	rgba[1] = (hex_to_dec(hex[3]) * 16 + hex_to_dec(hex[4])) / 255.0;
+	rgba[2] = (hex_to_dec(hex[5]) * 16 + hex_to_dec(hex[6])) / 255.0;
+	if (strlen(hex) > 7) {
+		rgba[3] = atoi(hex + 7) / 100.0;
+	} else {
+		rgba[3] = 1.0;
+	}
+}
+
 #endif /* LABWC_THEME_H */
diff --git a/include/window-rules.h b/include/window-rules.h
index fae1daf..ff8163e 100644
--- a/include/window-rules.h
+++ b/include/window-rules.h
@@ -18,6 +18,7 @@ enum property {
  *   - 'app_id' for native Wayland windows
  *   - 'WM_CLASS' for XWayland clients
  */
+
 struct window_rule {
 	char *identifier;
 	char *title;
@@ -32,11 +33,27 @@ struct window_rule {
 	enum property ignore_focus_request;
 
 	struct wl_list link; /* struct rcxml.window_rules */
+
+	/* Customisation window title and borders*/
+	bool has_custom_border;
+	float custom_border_color[4];
 };
 
 struct view;
 
+void init_window_rule(struct window_rule *rule);
+
 void window_rules_apply(struct view *view, enum window_rule_event event);
 enum property window_rules_get_property(struct view *view, const char *property);
 
+/**
+ * window_rules_get_custom_border_color - check for presence of custom color in window rules
+ * @view: view data
+ * @color: pointer to color array, where custom color will be copied to
+ * @return: true if color was found or false if not
+ */
+bool window_rules_get_custom_border_color(struct view *view, float *rgba);
+
+
+
 #endif /* LABWC_WINDOW_RULES_H */
diff --git a/src/config/rcxml.c b/src/config/rcxml.c
index c8da660..57e40f0 100644
--- a/src/config/rcxml.c
+++ b/src/config/rcxml.c
@@ -29,6 +29,7 @@
 #include "regions.h"
 #include "window-rules.h"
 #include "workspaces.h"
+#include "theme.h"
 
 static bool in_regions;
 static bool in_usable_area_override;
@@ -112,6 +113,7 @@ fill_window_rule(char *nodename, char *content)
 {
 	if (!strcasecmp(nodename, "windowRule.windowRules")) {
 		current_window_rule = znew(*current_window_rule);
+		init_window_rule(current_window_rule);
 		wl_list_append(&rc.window_rules, &current_window_rule->link);
 		wl_list_init(&current_window_rule->actions);
 		return;
@@ -127,6 +129,8 @@ fill_window_rule(char *nodename, char *content)
 	} else if (!strcmp(nodename, "identifier")) {
 		free(current_window_rule->identifier);
 		current_window_rule->identifier = xstrdup(content);
+		wlr_log(WLR_INFO, "Identifier found: %s=\"%s\"",
+                        nodename, content);
 	} else if (!strcmp(nodename, "title")) {
 		free(current_window_rule->title);
 		current_window_rule->title = xstrdup(content);
@@ -153,6 +157,14 @@ fill_window_rule(char *nodename, char *content)
 	} else if (!strcasecmp(nodename, "ignoreFocusRequest")) {
 		set_property(content, &current_window_rule->ignore_focus_request);
 
+	/* Custom border properties: color */
+	} else if (!strcasecmp(nodename, "borderColor")) {
+		parse_hexstr(content, current_window_rule->custom_border_color);
+		current_window_rule->has_custom_border = true;
+		wlr_log(WLR_DEBUG, "Custom borderColor was found in config: %s, parsed into: %f, %f, %f, %f\n",
+                        content, current_window_rule->custom_border_color[0], current_window_rule->custom_border_color[1], 
+						current_window_rule->custom_border_color[2], current_window_rule->custom_border_color[3]);
+
 	/* Actions */
 	} else if (!strcmp(nodename, "name.action")) {
 		current_window_rule_action = action_create(content);
diff --git a/src/ssd/ssd.c b/src/ssd/ssd.c
index ef821b8..8fe1479 100644
--- a/src/ssd/ssd.c
+++ b/src/ssd/ssd.c
@@ -333,9 +333,12 @@ ssd_enable_keybind_inhibit_indicator(struct ssd *ssd, bool enable)
 		return;
 	}
 
-	float *color = enable
-		? rc.theme->window_toggled_keybinds_color
-		: rc.theme->window_active_border_color;
+	float customColor[4];
+	bool isCustomColorAvailable = window_rules_get_custom_border_color(ssd->view, customColor);
+
+	float *color = isCustomColorAvailable ? customColor :
+		(enable ? rc.theme->window_toggled_keybinds_color
+				: rc.theme->window_active_border_color);
 
 	struct ssd_part *part = ssd_get_part(&ssd->border.active.parts, LAB_SSD_PART_TOP);
 	struct wlr_scene_rect *rect = lab_wlr_scene_get_rect(part->node);
diff --git a/src/ssd/ssd_border.c b/src/ssd/ssd_border.c
index 6512ab8..6e82694 100644
--- a/src/ssd/ssd_border.c
+++ b/src/ssd/ssd_border.c
@@ -6,6 +6,7 @@
 #include "ssd-internal.h"
 #include "theme.h"
 #include "view.h"
+#include "window-rules.h"
 
 #define FOR_EACH_STATE(ssd, tmp) FOR_EACH(tmp, \
 	&(ssd)->border.active, \
@@ -33,12 +34,30 @@ ssd_border_create(struct ssd *ssd)
 	FOR_EACH_STATE(ssd, subtree) {
 		subtree->tree = wlr_scene_tree_create(ssd->border.tree);
 		parent = subtree->tree;
+
+		/* 1st approach: the whole theme changing */
+		struct theme custom_theme= { 0 };
+		float customColor[4];
+		if (window_rules_get_custom_border_color(view, customColor)) {
+			theme_customize_with_border_color(&custom_theme, customColor);
+			theme = &custom_theme;
+		}
+
+		/* 2nd approach: the color changing */
+		//float customColor[4];
+		//bool isCustomColorAvailable = window_rules_get_custom_border_color(view, customColor);
+		//if (isCustomColorAvailable)
+		//	color = customColor; 
+		//else  {
 		if (subtree == &ssd->border.active) {
 			color = theme->window_active_border_color;
+			wlr_scene_node_set_enabled(&parent->node, true);
 		} else {
 			color = theme->window_inactive_border_color;
 			wlr_scene_node_set_enabled(&parent->node, false);
 		}
+		//}
+
 		wl_list_init(&subtree->parts);
 		add_scene_rect(&subtree->parts, LAB_SSD_PART_LEFT, parent,
 			theme->border_width, height, 0, 0, color);
diff --git a/src/ssd/ssd_part.c b/src/ssd/ssd_part.c
index 4c72d29..9399435 100644
--- a/src/ssd/ssd_part.c
+++ b/src/ssd/ssd_part.c
@@ -80,12 +80,11 @@ add_scene_buffer(struct wl_list *list, enum ssd_part_type type,
 
 struct ssd_part *
 add_scene_button_corner(struct wl_list *part_list, enum ssd_part_type type,
-		enum ssd_part_type corner_type, struct wlr_scene_tree *parent,
+		enum ssd_part_type corner_type, struct wlr_scene_tree *parent, float *bg_color,
 		struct wlr_buffer *corner_buffer, struct wlr_buffer *icon_buffer,
 		int x, struct view *view)
 {
 	int offset_x;
-	float invisible[4] = { 0, 0, 0, 0 };
 
 	if (corner_type == LAB_SSD_PART_CORNER_TOP_LEFT) {
 		offset_x = rc.theme->border_width;
@@ -107,8 +106,8 @@ add_scene_button_corner(struct wl_list *part_list, enum ssd_part_type type,
 	add_scene_buffer(part_list, corner_type, parent, corner_buffer,
 		-offset_x, -rc.theme->border_width);
 
-	/* Finally just put a usual theme button on top, using an invisible hitbox */
-	add_scene_button(part_list, type, parent, invisible, icon_buffer, 0, view);
+	/* Finally just put a usual theme button on top, using an invisible/custom colored hitbox */
+	add_scene_button(part_list, type, parent, bg_color, icon_buffer, 0, view);
 	return button_root;
 }
 
diff --git a/src/ssd/ssd_titlebar.c b/src/ssd/ssd_titlebar.c
index b0aaa2d..745e76b 100644
--- a/src/ssd/ssd_titlebar.c
+++ b/src/ssd/ssd_titlebar.c
@@ -24,6 +24,15 @@ ssd_titlebar_create(struct ssd *ssd)
 {
 	struct view *view = ssd->view;
 	struct theme *theme = view->server->theme;
+
+	/* 1st approach: the whole theme changing */
+	struct theme custom_theme= { 0 };
+	float customColor[4];
+	if (window_rules_get_custom_border_color(view, customColor)) {
+		theme_customize_with_border_color(&custom_theme, customColor);
+		theme = &custom_theme;
+	}
+
 	int width = view->current.width;
 
 	float *color;
@@ -43,6 +52,7 @@ ssd_titlebar_create(struct ssd *ssd)
 		subtree->tree = wlr_scene_tree_create(ssd->titlebar.tree);
 		parent = subtree->tree;
 		wlr_scene_node_set_position(&parent->node, 0, -theme->title_height);
+		
 		if (subtree == &ssd->titlebar.active) {
 			color = theme->window_active_title_bg_color;
 			corner_top_left = &theme->corner_top_left_active_normal->base;
@@ -62,6 +72,18 @@ ssd_titlebar_create(struct ssd *ssd)
 			close_button_unpressed = &theme->button_close_inactive_unpressed->base;
 			wlr_scene_node_set_enabled(&parent->node, false);
 		}
+		
+		/* 2nd approach: colors changing
+		float customColor[4];
+		bool isCustomColorAvailable = window_rules_get_custom_border_color(view, customColor);
+		if (isCustomColorAvailable) {
+			color = customColor;
+			//not clear, who owns the buffer and when it gets memory free
+			corner_top_left = &theme_create_custom_corner(theme, LAB_CORNER_TOP_LEFT, color)->base;
+			corner_top_right = &theme_create_custom_corner(theme, LAB_CORNER_TOP_RIGHT, color)->base;
+		}
+		*/
+
 		wl_list_init(&subtree->parts);
 
 		/* Title */
@@ -71,7 +93,7 @@ ssd_titlebar_create(struct ssd *ssd)
 		/* Buttons */
 		add_scene_button_corner(&subtree->parts,
 			LAB_SSD_BUTTON_WINDOW_MENU, LAB_SSD_PART_CORNER_TOP_LEFT, parent,
-			corner_top_left, menu_button_unpressed, 0, view);
+			color, corner_top_left, menu_button_unpressed, 0, view);
 		add_scene_button(&subtree->parts, LAB_SSD_BUTTON_ICONIFY, parent,
 			color, iconify_button_unpressed,
 			width - SSD_BUTTON_WIDTH * 3, view);
@@ -80,7 +102,7 @@ ssd_titlebar_create(struct ssd *ssd)
 			width - SSD_BUTTON_WIDTH * 2, view);
 		add_scene_button_corner(&subtree->parts,
 			LAB_SSD_BUTTON_CLOSE, LAB_SSD_PART_CORNER_TOP_RIGHT, parent,
-			corner_top_right, close_button_unpressed,
+			color, corner_top_right, close_button_unpressed,
 			width - SSD_BUTTON_WIDTH * 1, view);
 	} FOR_EACH_END
 
@@ -111,10 +133,13 @@ set_squared_corners(struct ssd *ssd, bool enable)
 
 			/* Toggle background between invisible and titlebar background color */
 			struct wlr_scene_rect *rect = lab_wlr_scene_get_rect(button->background);
-			wlr_scene_rect_set_color(rect, !enable ? (float[4]) {0, 0, 0, 0} : (
+			/*Check for custom color as well*/
+			float customColor[4];
+            bool isCustomColorAvailable = window_rules_get_custom_border_color(ssd->view, customColor);
+			wlr_scene_rect_set_color(rect, isCustomColorAvailable ? customColor : (!enable ? (float[4]) {0, 0, 0, 0} : (
 				subtree == &ssd->titlebar.active
 					? rc.theme->window_active_title_bg_color
-					: rc.theme->window_inactive_title_bg_color));
+					: rc.theme->window_inactive_title_bg_color)));
 
 			/* Toggle rounded corner image itself */
 			struct wlr_scene_node *rounded_corner =
diff --git a/src/theme.c b/src/theme.c
index 37dc803..a7eb3fb 100644
--- a/src/theme.c
+++ b/src/theme.c
@@ -148,42 +148,6 @@ load_buttons(struct theme *theme)
 	}
 }
 
-static int
-hex_to_dec(char c)
-{
-	if (c >= '0' && c <= '9') {
-		return c - '0';
-	}
-	if (c >= 'a' && c <= 'f') {
-		return c - 'a' + 10;
-	}
-	if (c >= 'A' && c <= 'F') {
-		return c - 'A' + 10;
-	}
-	return 0;
-}
-
-/**
- * parse_hexstr - parse #rrggbb
- * @hex: hex string to be parsed
- * @rgba: pointer to float[4] for return value
- */
-static void
-parse_hexstr(const char *hex, float *rgba)
-{
-	if (!hex || hex[0] != '#' || strlen(hex) < 7) {
-		return;
-	}
-	rgba[0] = (hex_to_dec(hex[1]) * 16 + hex_to_dec(hex[2])) / 255.0;
-	rgba[1] = (hex_to_dec(hex[3]) * 16 + hex_to_dec(hex[4])) / 255.0;
-	rgba[2] = (hex_to_dec(hex[5]) * 16 + hex_to_dec(hex[6])) / 255.0;
-	if (strlen(hex) > 7) {
-		rgba[3] = atoi(hex + 7) / 100.0;
-	} else {
-		rgba[3] = 1.0;
-	}
-}
-
 static enum lab_justification
 parse_justification(const char *str)
 {
@@ -211,7 +175,7 @@ parse_justification(const char *str)
 static void
 theme_builtin(struct theme *theme)
 {
-	theme->border_width = 1;
+	theme->border_width = 5;
 	theme->padding_height = 3;
 	theme->menu_overlap_x = 0;
 	theme->menu_overlap_y = 0;
@@ -541,11 +505,7 @@ struct rounded_corner_ctx {
 	double line_width;
 	float *fill_color;
 	float *border_color;
-	enum {
-		LAB_CORNER_UNKNOWN = 0,
-		LAB_CORNER_TOP_LEFT,
-		LAB_CORNER_TOP_RIGHT,
-	} corner;
+	enum lab_corner corner;
 };
 
 static struct lab_data_buffer *
@@ -747,6 +707,28 @@ create_corners(struct theme *theme)
 	theme->corner_top_right_inactive_normal = rounded_rect(&ctx);
 }
 
+struct lab_data_buffer * theme_create_custom_corner(struct theme *theme, enum lab_corner corner, float *bg_color)
+{
+	struct wlr_box box = {
+		.x = 0,
+		.y = 0,
+		.width = SSD_BUTTON_WIDTH + theme->border_width,
+		.height = theme->title_height + theme->border_width,
+	};
+
+	struct rounded_corner_ctx ctx = {
+		.box = &box,
+		.radius = rc.corner_radius,
+		.line_width = theme->border_width,
+		.fill_color = bg_color,
+		.border_color = bg_color,
+		.corner = corner,
+	};
+
+	//not clear, who owns the buffer and when it gets memory free
+	return rounded_rect(&ctx);
+}
+
 static void
 post_processing(struct theme *theme)
 {
@@ -829,3 +811,28 @@ theme_finish(struct theme *theme)
 	theme->corner_top_right_active_normal = NULL;
 	theme->corner_top_right_inactive_normal = NULL;
 }
+
+void theme_customize_with_border_color(struct theme *theme, float *color)
+{
+	theme_builtin(theme);
+
+	/* Read <data-dir>/share/themes/$theme_name/openbox-3/themerc */
+	//theme_read(theme, theme_name);
+
+	/* Read <config-dir>/labwc/themerc-override */
+	//theme_read_override(theme);
+	
+	memcpy(theme->window_active_border_color, color, sizeof(float)*4);
+	memcpy(theme->window_inactive_border_color, color, sizeof(float)*4);
+	memcpy(theme->window_active_title_bg_color, color, sizeof(float)*4);
+	memcpy(theme->window_inactive_title_bg_color, color, sizeof(float)*4);
+	
+	//?
+	memcpy(theme->osd_bg_color, color, sizeof(float)*4);
+	memcpy(theme->osd_border_color, color, sizeof(float)*4);
+	memcpy(theme->window_toggled_keybinds_color, color, sizeof(float)*4);
+
+	post_processing(theme);
+	create_corners(theme);
+	load_buttons(theme);
+}
\ No newline at end of file
diff --git a/src/window-rules.c b/src/window-rules.c
index 2607199..7fc8d34 100644
--- a/src/window-rules.c
+++ b/src/window-rules.c
@@ -74,6 +74,14 @@ view_matches_criteria(struct window_rule *rule, struct view *view)
 	}
 }
 
+void 
+init_window_rule(struct window_rule *rule) 
+{
+	if (!rule) return;
+	rule->has_custom_border = false;
+	memset(rule->custom_border_color, 0, sizeof(float)*4);
+}
+
 void
 window_rules_apply(struct view *view, enum window_rule_event event)
 {
@@ -132,3 +140,20 @@ window_rules_get_property(struct view *view, const char *property)
 	}
 	return LAB_PROP_UNSPECIFIED;
 }
+
+bool
+window_rules_get_custom_border_color(struct view *view, float* rgba)
+{
+	struct window_rule *rule;
+	wl_list_for_each_reverse(rule, &rc.window_rules, link) {
+		if (view_matches_criteria(rule, view)) {
+			if (rule->has_custom_border) {
+				memcpy(rgba, rule->custom_border_color, sizeof(float)*4);
+				wlr_log(WLR_DEBUG, "Custom color was found in window rules list: %f, %f, %f, %f\n", rgba[0], rgba[1], rgba[2], rgba[3]);
+				return true;
+			}
+		}
+	}
+	
+	return false;
+}
